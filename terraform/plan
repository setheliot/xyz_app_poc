Acquiring state lock. This may take a few moments...
[0m[1mdata.terraform_remote_state.infra: Reading...[0m[0m
[0m[1mdata.terraform_remote_state.infra: Read complete after 3s[0m
[0m[1mdata.aws_eks_cluster.cluster: Reading...[0m[0m
[0m[1mdata.aws_eks_cluster.cluster: Read complete after 1s [id=eks-cluster-xyz-stage][0m

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m

Terraform will perform the following actions:

[1m  # kubernetes_deployment.xyz-demo-app[0m will be created
[0m  [32m+[0m[0m resource "kubernetes_deployment" "xyz-demo-app" {
      [32m+[0m[0m id               = (known after apply)
      [32m+[0m[0m wait_for_rollout = true

      [32m+[0m[0m metadata {
          [32m+[0m[0m generation       = (known after apply)
          [32m+[0m[0m labels           = {
              [32m+[0m[0m "App" = "XYZDemoApp-stage"
            }
          [32m+[0m[0m name             = "xyz-demo-app-stage"
          [32m+[0m[0m namespace        = "default"
          [32m+[0m[0m resource_version = (known after apply)
          [32m+[0m[0m uid              = (known after apply)
        }

      [32m+[0m[0m spec {
          [32m+[0m[0m min_ready_seconds         = 0
          [32m+[0m[0m paused                    = false
          [32m+[0m[0m progress_deadline_seconds = 600
          [32m+[0m[0m replicas                  = "2"
          [32m+[0m[0m revision_history_limit    = 10

          [32m+[0m[0m selector {
              [32m+[0m[0m match_labels = {
                  [32m+[0m[0m "App" = "XYZDemoApp-stage"
                }
            }

          [32m+[0m[0m strategy (known after apply)

          [32m+[0m[0m template {
              [32m+[0m[0m metadata {
                  [32m+[0m[0m generation       = (known after apply)
                  [32m+[0m[0m labels           = {
                      [32m+[0m[0m "App" = "XYZDemoApp-stage"
                    }
                  [32m+[0m[0m name             = (known after apply)
                  [32m+[0m[0m resource_version = (known after apply)
                  [32m+[0m[0m uid              = (known after apply)
                }
              [32m+[0m[0m spec {
                  [32m+[0m[0m automount_service_account_token  = true
                  [32m+[0m[0m dns_policy                       = "ClusterFirst"
                  [32m+[0m[0m enable_service_links             = true
                  [32m+[0m[0m host_ipc                         = false
                  [32m+[0m[0m host_network                     = false
                  [32m+[0m[0m host_pid                         = false
                  [32m+[0m[0m hostname                         = (known after apply)
                  [32m+[0m[0m node_name                        = (known after apply)
                  [32m+[0m[0m restart_policy                   = "Always"
                  [32m+[0m[0m scheduler_name                   = (known after apply)
                  [32m+[0m[0m service_account_name             = (known after apply)
                  [32m+[0m[0m share_process_namespace          = false
                  [32m+[0m[0m termination_grace_period_seconds = 30

                  [32m+[0m[0m container {
                      [32m+[0m[0m image                      = "ghcr.io/setheliot/xyz-demo-app:latest"
                      [32m+[0m[0m image_pull_policy          = (known after apply)
                      [32m+[0m[0m name                       = "xyzdemoapp-container-stage"
                      [32m+[0m[0m stdin                      = false
                      [32m+[0m[0m stdin_once                 = false
                      [32m+[0m[0m termination_message_path   = "/dev/termination-log"
                      [32m+[0m[0m termination_message_policy = (known after apply)
                      [32m+[0m[0m tty                        = false

                      [32m+[0m[0m port {
                          [32m+[0m[0m container_port = 80
                          [32m+[0m[0m protocol       = "TCP"
                        }

                      [32m+[0m[0m resources {
                          [32m+[0m[0m limits   = {
                              [32m+[0m[0m "cpu"    = "0.5"
                              [32m+[0m[0m "memory" = "512Mi"
                            }
                          [32m+[0m[0m requests = {
                              [32m+[0m[0m "cpu"    = "250m"
                              [32m+[0m[0m "memory" = "50Mi"
                            }
                        }
                    }

                  [32m+[0m[0m image_pull_secrets (known after apply)

                  [32m+[0m[0m readiness_gate (known after apply)
                }
            }
        }
    }

[1m  # kubernetes_service.xyz-demo-elb[0m will be created
[0m  [32m+[0m[0m resource "kubernetes_service" "xyz-demo-elb" {
      [32m+[0m[0m id                     = (known after apply)
      [32m+[0m[0m status                 = (known after apply)
      [32m+[0m[0m wait_for_load_balancer = true

      [32m+[0m[0m metadata {
          [32m+[0m[0m annotations      = {
              [32m+[0m[0m "service.beta.kubernetes.io/aws-load-balancer-type" = "nlb"
            }
          [32m+[0m[0m generation       = (known after apply)
          [32m+[0m[0m name             = "xyz-demo-elb-prod"
          [32m+[0m[0m namespace        = "default"
          [32m+[0m[0m resource_version = (known after apply)
          [32m+[0m[0m uid              = (known after apply)
        }

      [32m+[0m[0m spec {
          [32m+[0m[0m allocate_load_balancer_node_ports = true
          [32m+[0m[0m cluster_ip                        = (known after apply)
          [32m+[0m[0m cluster_ips                       = (known after apply)
          [32m+[0m[0m external_traffic_policy           = (known after apply)
          [32m+[0m[0m health_check_node_port            = (known after apply)
          [32m+[0m[0m internal_traffic_policy           = (known after apply)
          [32m+[0m[0m ip_families                       = (known after apply)
          [32m+[0m[0m ip_family_policy                  = (known after apply)
          [32m+[0m[0m publish_not_ready_addresses       = false
          [32m+[0m[0m selector                          = {
              [32m+[0m[0m "App" = "XYZDemoApp-stage"
            }
          [32m+[0m[0m session_affinity                  = "None"
          [32m+[0m[0m type                              = "LoadBalancer"

          [32m+[0m[0m port {
              [32m+[0m[0m node_port   = (known after apply)
              [32m+[0m[0m port        = 80
              [32m+[0m[0m protocol    = "TCP"
              [32m+[0m[0m target_port = "80"
            }

          [32m+[0m[0m session_affinity_config (known after apply)
        }
    }

[1mPlan:[0m 2 to add, 0 to change, 0 to destroy.
[0m
Changes to Outputs:
  [32m+[0m[0m lb_ip = (known after apply)
[90m
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[0m

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
Releasing state lock. This may take a few moments...
