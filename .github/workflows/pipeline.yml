name: 'Pipeline'

# Do not run when PR is created - only after it is merged into one of these branches
# main branch is prod
on:
    push:
      branches:
        - main
        - stage


permissions:
  contents: read

env:
  RELEASE_REVISION: "pr-${{ github.event.pull_request.number }}-${{ github.event.pull_request.head.sha }}"
  SHA_SHORT: "latest"

jobs:
  build:
    name: 'Build: ${{ github.ref_name }}'
    runs-on: ubuntu-latest
    if: github.ref_name == 'main' || github.ref_name == 'stage'    

    environment: ${{ github.ref_name == 'stage' && 'stage' || github.ref_name == 'main' && 'prod' || 'unknown' }}

    defaults:
      run:
        shell: bash

    steps:
      # DELETE THIS
      # Docker login to GHCR - needed to be able to push image
      # We do not need this is Codespaces access is configured.  This gives direct access by this repo
      # https://docs.github.com/en/codespaces/reference/allowing-your-codespace-to-access-a-private-registry
      # - name: Log in to GitHub Container Registry
      #  run: echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u setheliot --password-stdin

      # create and boot a builder for multi-platform images
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Log in to GHCR
      - name: Log in to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: "setheliot"
          password: ${{ secrets.GHCR_TOKEN }}

      # Generate version label for the image
      - name: Set Short SHA
        run: echo "SHA_SHORT=${GITHUB_SHA::7}" >> $GITHUB_ENV
    
      # Build and push our image with the latest tag.
      - name: Build and push
        uses: docker/build-push-action@v3
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ghcr.io/setheliot/xyz-demo-app:latest,ghcr.io/setheliot/xyz-demo-app:${{env.SHA_SHORT}}


    ######################


  terraform:
    name: 'Terraform: ${{ github.ref_name }}'
    runs-on: ubuntu-latest
    if: github.ref_name == 'main' || github.ref_name == 'stage'    

    environment: ${{ github.ref_name == 'stage' && 'stage' || github.ref_name == 'main' && 'prod' || 'unknown' }}

    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      # Generate version label for the image
      - name: Set Short SHA
        run: echo "SHA_SHORT=${GITHUB_SHA::7}" >> $GITHUB_ENV

      # Supply an IAM User for AWS credentials.
      # ToDo: update to use IAM Role (short lived credentials) instead
      # Region is required here, but not used by Terraform - we specify Region in the Terraform provider 
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      # Setup Terraform
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1

      # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
      - name: Terraform Init
        run: terraform init

      # Checks that all Terraform configuration files adhere to a canonical format
      - name: Terraform Format
        run: terraform fmt -check

      # If the workspace does not exist, then something is wrong. It is likely the infrastructure
      # was not deployed correctly
      # (consider replacing the workspace based environment logic with Terragrunt later)
      - name: Ensure workspace exists for this branch (for this environment)
        run: |
          if ! terraform workspace list | grep -q "${{ github.ref_name }}"; then
            terraform workspace new "${{ github.ref_name }}"
          fi

      # Checks select the appropriate workspace - ensures separate state files for each env
      - name: Terraform Workspace
        run: terraform workspace select ${{ github.ref_name }}

      # Generates an execution plan for Terraform
      - name: Terraform Plan
        run: terraform plan -var-file=environment/${{ github.ref_name }}.tfvars

      - name: Terraform Apply
        run: | 
          terraform apply -auto-approve -input=false 
          -var="app_image=ghcr.io/setheliot/xyz-demo-app:${{env.SHA_SHORT}}" 
          -var-file=environment/${{ github.ref_name }}.tfvars